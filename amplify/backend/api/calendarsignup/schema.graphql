schema {
  query: Query
  mutation: Mutation
  subscription: Subscription
}

type Attendee {
  class: Class
  classAttendeesId: ID
  createdAt: AWSDateTime!
  firstName: String
  id: ID
  jjbelt: Int
  lastName: String
  llbelt: Int
  updatedAt: AWSDateTime!
  username: String
}

type Class {
  age: String
  attendees(
    filter: ModelAttendeeFilterInput
    limit: Int
    nextToken: String
    sortDirection: ModelSortDirection
  ): ModelAttendeeConnection
  classOpen: Boolean
  createdAt: AWSDateTime!
  day: Day
  dayClassesId: ID
  end: AWSTime
  id: ID!
  instructor: String
  maxSpots: Int
  message: String
  name: String
  openSpots: Int
  start: AWSTime
  type: String
  updatedAt: AWSDateTime!
}

type Day {
  classes(
    filter: ModelClassFilterInput
    limit: Int
    nextToken: String
    sortDirection: ModelSortDirection
  ): ModelClassConnection
  createdAt: AWSDateTime!
  date: AWSDate
  id: ID!
  open: Boolean
  updatedAt: AWSDateTime!
}

type ModelAttendeeConnection {
  items: [Attendee]!
  nextToken: String
}

type ModelClassConnection {
  items: [Class]!
  nextToken: String
}

type ModelDayConnection {
  items: [Day]!
  nextToken: String
}

type ModelUserConnection {
  items: [User]!
  nextToken: String
}

type ModelUserMonthConnection {
  items: [UserMonth]!
  nextToken: String
}

type Mutation {
  createAttendee(
    condition: ModelAttendeeConditionInput
    input: CreateAttendeeInput!
  ): Attendee
  createClass(
    condition: ModelClassConditionInput
    input: CreateClassInput!
  ): Class
  createDay(condition: ModelDayConditionInput, input: CreateDayInput!): Day
  createUser(condition: ModelUserConditionInput, input: CreateUserInput!): User
  createUserMonth(
    condition: ModelUserMonthConditionInput
    input: CreateUserMonthInput!
  ): UserMonth
  deleteAttendee(
    condition: ModelAttendeeConditionInput
    input: DeleteAttendeeInput!
  ): Attendee
  deleteClass(
    condition: ModelClassConditionInput
    input: DeleteClassInput!
  ): Class
  deleteDay(condition: ModelDayConditionInput, input: DeleteDayInput!): Day
  deleteUser(condition: ModelUserConditionInput, input: DeleteUserInput!): User
  deleteUserMonth(
    condition: ModelUserMonthConditionInput
    input: DeleteUserMonthInput!
  ): UserMonth
  updateAttendee(
    condition: ModelAttendeeConditionInput
    input: UpdateAttendeeInput!
  ): Attendee
  updateClass(
    condition: ModelClassConditionInput
    input: UpdateClassInput!
  ): Class
  updateDay(condition: ModelDayConditionInput, input: UpdateDayInput!): Day
  updateUser(condition: ModelUserConditionInput, input: UpdateUserInput!): User
  updateUserMonth(
    condition: ModelUserMonthConditionInput
    input: UpdateUserMonthInput!
  ): UserMonth
}

type Query {
  getAttendee(id: ID!): Attendee
  getClass(id: ID!): Class
  getDay(id: ID!): Day
  getUser(id: ID!): User
  getUserMonth(id: ID!): UserMonth
  listAttendees(
    filter: ModelAttendeeFilterInput
    limit: Int
    nextToken: String
  ): ModelAttendeeConnection
  listClasses(
    filter: ModelClassFilterInput
    limit: Int
    nextToken: String
  ): ModelClassConnection
  listDays(
    filter: ModelDayFilterInput
    limit: Int
    nextToken: String
  ): ModelDayConnection
  listUserMonths(
    filter: ModelUserMonthFilterInput
    limit: Int
    nextToken: String
  ): ModelUserMonthConnection
  listUsers(
    filter: ModelUserFilterInput
    limit: Int
    nextToken: String
  ): ModelUserConnection
}

type Subscription {
  onCreateAttendee(filter: ModelSubscriptionAttendeeFilterInput): Attendee
    @aws_subscribe(mutations: ["createAttendee"])
  onCreateClass(filter: ModelSubscriptionClassFilterInput): Class
    @aws_subscribe(mutations: ["createClass"])
  onCreateDay(filter: ModelSubscriptionDayFilterInput): Day
    @aws_subscribe(mutations: ["createDay"])
  onCreateUser(filter: ModelSubscriptionUserFilterInput): User
    @aws_subscribe(mutations: ["createUser"])
  onCreateUserMonth(filter: ModelSubscriptionUserMonthFilterInput): UserMonth
    @aws_subscribe(mutations: ["createUserMonth"])
  onDeleteAttendee(filter: ModelSubscriptionAttendeeFilterInput): Attendee
    @aws_subscribe(mutations: ["deleteAttendee"])
  onDeleteClass(filter: ModelSubscriptionClassFilterInput): Class
    @aws_subscribe(mutations: ["deleteClass"])
  onDeleteDay(filter: ModelSubscriptionDayFilterInput): Day
    @aws_subscribe(mutations: ["deleteDay"])
  onDeleteUser(filter: ModelSubscriptionUserFilterInput): User
    @aws_subscribe(mutations: ["deleteUser"])
  onDeleteUserMonth(filter: ModelSubscriptionUserMonthFilterInput): UserMonth
    @aws_subscribe(mutations: ["deleteUserMonth"])
  onUpdateAttendee(filter: ModelSubscriptionAttendeeFilterInput): Attendee
    @aws_subscribe(mutations: ["updateAttendee"])
  onUpdateClass(filter: ModelSubscriptionClassFilterInput): Class
    @aws_subscribe(mutations: ["updateClass"])
  onUpdateDay(filter: ModelSubscriptionDayFilterInput): Day
    @aws_subscribe(mutations: ["updateDay"])
  onUpdateUser(filter: ModelSubscriptionUserFilterInput): User
    @aws_subscribe(mutations: ["updateUser"])
  onUpdateUserMonth(filter: ModelSubscriptionUserMonthFilterInput): UserMonth
    @aws_subscribe(mutations: ["updateUserMonth"])
}

type User {
  classesTotal: Int
  createdAt: AWSDateTime!
  email: String
  enroll: AWSDate
  firstName: String
  freeze: Boolean
  freezeEnd: AWSDate
  freezeStart: AWSDate
  goal: Int
  hideEmail: Boolean
  hidePhone: Boolean
  id: ID!
  image: String
  insta: String
  jjbelt: Int
  lastName: String
  llbelt: Int
  phone: String
  progress: Int
  renew: AWSDate
  updatedAt: AWSDateTime!
  userMonths(
    filter: ModelUserMonthFilterInput
    limit: Int
    nextToken: String
    sortDirection: ModelSortDirection
  ): ModelUserMonthConnection
  username: String
}

type UserMonth {
  createdAt: AWSDateTime!
  id: ID!
  jj: Int
  kb: Int
  ll: Int
  month: Int
  updatedAt: AWSDateTime!
  user: User
  userUserMonthsId: ID
  year: Int
}

enum ModelAttributeTypes {
  _null
  binary
  binarySet
  bool
  list
  map
  number
  numberSet
  string
  stringSet
}

enum ModelSortDirection {
  ASC
  DESC
}

input CreateAttendeeInput {
  classAttendeesId: ID
  firstName: String
  id: ID
  jjbelt: Int
  lastName: String
  llbelt: Int
  username: String
}

input CreateClassInput {
  age: String
  classOpen: Boolean
  dayClassesId: ID
  end: AWSTime
  id: ID
  instructor: String
  maxSpots: Int
  message: String
  name: String
  openSpots: Int
  start: AWSTime
  type: String
}

input CreateDayInput {
  date: AWSDate
  id: ID
  open: Boolean
}

input CreateUserInput {
  classesTotal: Int
  email: String
  enroll: AWSDate
  firstName: String
  freeze: Boolean
  freezeEnd: AWSDate
  freezeStart: AWSDate
  goal: Int
  hideEmail: Boolean
  hidePhone: Boolean
  id: ID
  image: String
  insta: String
  jjbelt: Int
  lastName: String
  llbelt: Int
  phone: String
  progress: Int
  renew: AWSDate
  username: String
}

input CreateUserMonthInput {
  id: ID
  jj: Int
  kb: Int
  ll: Int
  month: Int
  userUserMonthsId: ID
  year: Int
}

input DeleteAttendeeInput {
  id: ID!
}

input DeleteClassInput {
  id: ID!
}

input DeleteDayInput {
  id: ID!
}

input DeleteUserInput {
  id: ID!
}

input DeleteUserMonthInput {
  id: ID!
}

input ModelAttendeeConditionInput {
  and: [ModelAttendeeConditionInput]
  classAttendeesId: ModelIDInput
  firstName: ModelStringInput
  jjbelt: ModelIntInput
  lastName: ModelStringInput
  llbelt: ModelIntInput
  not: ModelAttendeeConditionInput
  or: [ModelAttendeeConditionInput]
  username: ModelStringInput
}

input ModelAttendeeFilterInput {
  and: [ModelAttendeeFilterInput]
  classAttendeesId: ModelIDInput
  firstName: ModelStringInput
  id: ModelIDInput
  jjbelt: ModelIntInput
  lastName: ModelStringInput
  llbelt: ModelIntInput
  not: ModelAttendeeFilterInput
  or: [ModelAttendeeFilterInput]
  username: ModelStringInput
}

input ModelBooleanInput {
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
  eq: Boolean
  ne: Boolean
}

input ModelClassConditionInput {
  age: ModelStringInput
  and: [ModelClassConditionInput]
  classOpen: ModelBooleanInput
  dayClassesId: ModelIDInput
  end: ModelStringInput
  instructor: ModelStringInput
  maxSpots: ModelIntInput
  message: ModelStringInput
  name: ModelStringInput
  not: ModelClassConditionInput
  openSpots: ModelIntInput
  or: [ModelClassConditionInput]
  start: ModelStringInput
  type: ModelStringInput
}

input ModelClassFilterInput {
  age: ModelStringInput
  and: [ModelClassFilterInput]
  classOpen: ModelBooleanInput
  dayClassesId: ModelIDInput
  end: ModelStringInput
  id: ModelIDInput
  instructor: ModelStringInput
  maxSpots: ModelIntInput
  message: ModelStringInput
  name: ModelStringInput
  not: ModelClassFilterInput
  openSpots: ModelIntInput
  or: [ModelClassFilterInput]
  start: ModelStringInput
  type: ModelStringInput
}

input ModelDayConditionInput {
  and: [ModelDayConditionInput]
  date: ModelStringInput
  not: ModelDayConditionInput
  open: ModelBooleanInput
  or: [ModelDayConditionInput]
}

input ModelDayFilterInput {
  and: [ModelDayFilterInput]
  date: ModelStringInput
  id: ModelIDInput
  not: ModelDayFilterInput
  open: ModelBooleanInput
  or: [ModelDayFilterInput]
}

input ModelFloatInput {
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
  between: [Float]
  eq: Float
  ge: Float
  gt: Float
  le: Float
  lt: Float
  ne: Float
}

input ModelIDInput {
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
  beginsWith: ID
  between: [ID]
  contains: ID
  eq: ID
  ge: ID
  gt: ID
  le: ID
  lt: ID
  ne: ID
  notContains: ID
  size: ModelSizeInput
}

input ModelIntInput {
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
  between: [Int]
  eq: Int
  ge: Int
  gt: Int
  le: Int
  lt: Int
  ne: Int
}

input ModelSizeInput {
  between: [Int]
  eq: Int
  ge: Int
  gt: Int
  le: Int
  lt: Int
  ne: Int
}

input ModelStringInput {
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
  beginsWith: String
  between: [String]
  contains: String
  eq: String
  ge: String
  gt: String
  le: String
  lt: String
  ne: String
  notContains: String
  size: ModelSizeInput
}

input ModelSubscriptionAttendeeFilterInput {
  and: [ModelSubscriptionAttendeeFilterInput]
  firstName: ModelSubscriptionStringInput
  id: ModelSubscriptionIDInput
  jjbelt: ModelSubscriptionIntInput
  lastName: ModelSubscriptionStringInput
  llbelt: ModelSubscriptionIntInput
  or: [ModelSubscriptionAttendeeFilterInput]
  username: ModelSubscriptionStringInput
}

input ModelSubscriptionBooleanInput {
  eq: Boolean
  ne: Boolean
}

input ModelSubscriptionClassFilterInput {
  age: ModelSubscriptionStringInput
  and: [ModelSubscriptionClassFilterInput]
  classOpen: ModelSubscriptionBooleanInput
  end: ModelSubscriptionStringInput
  id: ModelSubscriptionIDInput
  instructor: ModelSubscriptionStringInput
  maxSpots: ModelSubscriptionIntInput
  message: ModelSubscriptionStringInput
  name: ModelSubscriptionStringInput
  openSpots: ModelSubscriptionIntInput
  or: [ModelSubscriptionClassFilterInput]
  start: ModelSubscriptionStringInput
  type: ModelSubscriptionStringInput
}

input ModelSubscriptionDayFilterInput {
  and: [ModelSubscriptionDayFilterInput]
  date: ModelSubscriptionStringInput
  id: ModelSubscriptionIDInput
  open: ModelSubscriptionBooleanInput
  or: [ModelSubscriptionDayFilterInput]
}

input ModelSubscriptionFloatInput {
  between: [Float]
  eq: Float
  ge: Float
  gt: Float
  in: [Float]
  le: Float
  lt: Float
  ne: Float
  notIn: [Float]
}

input ModelSubscriptionIDInput {
  beginsWith: ID
  between: [ID]
  contains: ID
  eq: ID
  ge: ID
  gt: ID
  in: [ID]
  le: ID
  lt: ID
  ne: ID
  notContains: ID
  notIn: [ID]
}

input ModelSubscriptionIntInput {
  between: [Int]
  eq: Int
  ge: Int
  gt: Int
  in: [Int]
  le: Int
  lt: Int
  ne: Int
  notIn: [Int]
}

input ModelSubscriptionStringInput {
  beginsWith: String
  between: [String]
  contains: String
  eq: String
  ge: String
  gt: String
  in: [String]
  le: String
  lt: String
  ne: String
  notContains: String
  notIn: [String]
}

input ModelSubscriptionUserFilterInput {
  and: [ModelSubscriptionUserFilterInput]
  classesTotal: ModelSubscriptionIntInput
  email: ModelSubscriptionStringInput
  enroll: ModelSubscriptionStringInput
  firstName: ModelSubscriptionStringInput
  freeze: ModelSubscriptionBooleanInput
  freezeEnd: ModelSubscriptionStringInput
  freezeStart: ModelSubscriptionStringInput
  goal: ModelSubscriptionIntInput
  hideEmail: ModelSubscriptionBooleanInput
  hidePhone: ModelSubscriptionBooleanInput
  id: ModelSubscriptionIDInput
  image: ModelSubscriptionStringInput
  insta: ModelSubscriptionStringInput
  jjbelt: ModelSubscriptionIntInput
  lastName: ModelSubscriptionStringInput
  llbelt: ModelSubscriptionIntInput
  or: [ModelSubscriptionUserFilterInput]
  phone: ModelSubscriptionStringInput
  progress: ModelSubscriptionIntInput
  renew: ModelSubscriptionStringInput
  username: ModelSubscriptionStringInput
}

input ModelSubscriptionUserMonthFilterInput {
  and: [ModelSubscriptionUserMonthFilterInput]
  id: ModelSubscriptionIDInput
  jj: ModelSubscriptionIntInput
  kb: ModelSubscriptionIntInput
  ll: ModelSubscriptionIntInput
  month: ModelSubscriptionIntInput
  or: [ModelSubscriptionUserMonthFilterInput]
  year: ModelSubscriptionIntInput
}

input ModelUserConditionInput {
  and: [ModelUserConditionInput]
  classesTotal: ModelIntInput
  email: ModelStringInput
  enroll: ModelStringInput
  firstName: ModelStringInput
  freeze: ModelBooleanInput
  freezeEnd: ModelStringInput
  freezeStart: ModelStringInput
  goal: ModelIntInput
  hideEmail: ModelBooleanInput
  hidePhone: ModelBooleanInput
  image: ModelStringInput
  insta: ModelStringInput
  jjbelt: ModelIntInput
  lastName: ModelStringInput
  llbelt: ModelIntInput
  not: ModelUserConditionInput
  or: [ModelUserConditionInput]
  phone: ModelStringInput
  progress: ModelIntInput
  renew: ModelStringInput
  username: ModelStringInput
}

input ModelUserFilterInput {
  and: [ModelUserFilterInput]
  classesTotal: ModelIntInput
  email: ModelStringInput
  enroll: ModelStringInput
  firstName: ModelStringInput
  freeze: ModelBooleanInput
  freezeEnd: ModelStringInput
  freezeStart: ModelStringInput
  goal: ModelIntInput
  hideEmail: ModelBooleanInput
  hidePhone: ModelBooleanInput
  id: ModelIDInput
  image: ModelStringInput
  insta: ModelStringInput
  jjbelt: ModelIntInput
  lastName: ModelStringInput
  llbelt: ModelIntInput
  not: ModelUserFilterInput
  or: [ModelUserFilterInput]
  phone: ModelStringInput
  progress: ModelIntInput
  renew: ModelStringInput
  username: ModelStringInput
}

input ModelUserMonthConditionInput {
  and: [ModelUserMonthConditionInput]
  jj: ModelIntInput
  kb: ModelIntInput
  ll: ModelIntInput
  month: ModelIntInput
  not: ModelUserMonthConditionInput
  or: [ModelUserMonthConditionInput]
  userUserMonthsId: ModelIDInput
  year: ModelIntInput
}

input ModelUserMonthFilterInput {
  and: [ModelUserMonthFilterInput]
  id: ModelIDInput
  jj: ModelIntInput
  kb: ModelIntInput
  ll: ModelIntInput
  month: ModelIntInput
  not: ModelUserMonthFilterInput
  or: [ModelUserMonthFilterInput]
  userUserMonthsId: ModelIDInput
  year: ModelIntInput
}

input UpdateAttendeeInput {
  classAttendeesId: ID
  firstName: String
  id: ID!
  jjbelt: Int
  lastName: String
  llbelt: Int
  username: String
}

input UpdateClassInput {
  age: String
  classOpen: Boolean
  dayClassesId: ID
  end: AWSTime
  id: ID!
  instructor: String
  maxSpots: Int
  message: String
  name: String
  openSpots: Int
  start: AWSTime
  type: String
}

input UpdateDayInput {
  date: AWSDate
  id: ID!
  open: Boolean
}

input UpdateUserInput {
  classesTotal: Int
  email: String
  enroll: AWSDate
  firstName: String
  freeze: Boolean
  freezeEnd: AWSDate
  freezeStart: AWSDate
  goal: Int
  hideEmail: Boolean
  hidePhone: Boolean
  id: ID!
  image: String
  insta: String
  jjbelt: Int
  lastName: String
  llbelt: Int
  phone: String
  progress: Int
  renew: AWSDate
  username: String
}

input UpdateUserMonthInput {
  id: ID!
  jj: Int
  kb: Int
  ll: Int
  month: Int
  userUserMonthsId: ID
  year: Int
}
